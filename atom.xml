<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风成的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liyang.comeonone.com/"/>
  <updated>2020-03-26T15:38:06.164Z</updated>
  <id>http://liyang.comeonone.com/</id>
  
  <author>
    <name>liyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日一问</title>
    <link href="http://liyang.comeonone.com/2020/03/26/daily-20200326/"/>
    <id>http://liyang.comeonone.com/2020/03/26/daily-20200326/</id>
    <published>2020-03-26T15:07:16.000Z</published>
    <updated>2020-03-26T15:38:06.164Z</updated>
    
    <content type="html"><![CDATA[<div style="font-size:18px;color:#333;line-height:20px;font-family:楷体;"><h4 id="1-React中关于render函数返回一个元素"><a href="#1-React中关于render函数返回一个元素" class="headerlink" title="1.React中关于render函数返回一个元素 "></a><font style="font-weight:700;color:#333;font-size:20px;">1.React中关于render函数返回一个元素 </font></h4><h5 id="问题需求"><a href="#问题需求" class="headerlink" title="问题需求 "></a><font style="font-weight:700;color:#333;">问题需求 </font></h5><pre><code>当在render返回的方法中，需要返回多个根节点时候会如何</code></pre><h5 id="关于Jsx"><a href="#关于Jsx" class="headerlink" title="关于Jsx "></a><font style="font-weight:700;color:#333;">关于Jsx </font></h5><p><font style="color:blue;">由于react jsx是javascript的语法拓展，其本质是 通过React.createElement(type, config, children)来返回一个React元素</font></p><pre><code>class App extends React.Component {  render(){    return (      &lt;div&gt;      hello      &lt;/div&gt;    );  }}</code></pre><p>转变这样</p><pre><code>_createClass(App, [{    key: &apos;render&apos;,    value: function render() {      return React.createElement(&quot;div&quot;, null, &quot;hello&quot;);    }}]);</code></pre><p>如果写成多个元素</p><pre><code>class App extends React.Component {  render(){    return (      &lt;div&gt;      hello      &lt;/div&gt;      &lt;h1&gt;more&lt;/h1&gt;    );  }}</code></pre><p>其将会装换为</p><pre><code>_createClass(App, [{    key: &apos;render&apos;,    value: function render() {      return React.createElement(&quot;div&quot;, null, &quot;hello&quot;);      return React.createElement(&quot;h1&quot;, null, &quot;more&quot;);    }}]);</code></pre><p>其实际上不会转换成功(将会报错 Adjacent JSX elements must be wrapped in an enclosing tag)其方法return两次，这显然是错误</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="1-父元素包裹"><a href="#1-父元素包裹" class="headerlink" title="1.父元素包裹 "></a><font style="font-weight:700;color:#333;">1.父元素包裹 </font></h6><pre><code>render() {  return (    &lt;div&gt;      &lt;h1&gt;foo&lt;/h1&gt;      &lt;h2&gt;bar&lt;/h2&gt;    &lt;/div&gt;  );}</code></pre><h6 id="2-采用-Fragment"><a href="#2-采用-Fragment" class="headerlink" title="2.采用 Fragment  "></a><font style="font-weight:700;color:#333;">2.采用 Fragment  </font></h6><p>在 React v16.2+以上版本中可以才用Fragment片段的方式</p><pre><code>render() {    return (      &lt;React.Fragment&gt;        &lt;td&gt;Hello&lt;/td&gt;        &lt;td&gt;World&lt;/td&gt;      &lt;/React.Fragment&gt;    );}  </code></pre><h6 id="3-短语法-lt-gt-lt-gt"><a href="#3-短语法-lt-gt-lt-gt" class="headerlink" title="3.短语法 &lt;&gt; &lt;/&gt;  "></a><font style="font-weight:700;color:#333;">3.短语法 &lt;&gt; &lt;/&gt;  </font></h6><pre><code>render() {    return (      &lt;&gt;        &lt;td&gt;Hello&lt;/td&gt;        &lt;td&gt;World&lt;/td&gt;      &lt;/&gt;    ); }jsx部分 其转换为React.createElement(React.Fragment, null,     React.createElement(&quot;td&quot;, null, &quot;Hello&quot;),     React.createElement(&quot;td&quot;, null, &quot;World&quot;));    </code></pre><p>可以看出 其实际上是React.Fragment的语法糖 可以写成</p><pre><code>render() {  return (    &lt;React.Fragment&gt;    &lt;td&gt;Hello&lt;/td&gt;    &lt;td&gt;World&lt;/td&gt;    &lt;/React.Fragment&gt;  );}</code></pre><h6 id="4-返回数组"><a href="#4-返回数组" class="headerlink" title="4.返回数组 "></a><font style="font-weight:700;color:#333;">4.返回数组 </font></h6><p>在 React v16.0+以上版本中可以才用返回数组的方式</p><pre><code>render(){    return [&lt;div key={0}&gt;hello&lt;/div&gt;,&lt;div key={1}&gt;world&lt;/div&gt;]}</code></pre><p>其会转化为</p><pre><code>return [    React.createElement(&quot;div&quot;, {key: 0}, &quot;hello&quot;),    React.createElement(&quot;div&quot;, {key: 1}, &quot;world&quot;)];</code></pre><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://stackoverflow.com/questions/31284169/parse-error-adjacent-jsx-elements-must-be-wrapped-in-an-enclosing-tag" target="_blank" rel="noopener">Adjacent JSX error</a></p><p><a href="https://zh-hans.reactjs.org/docs/fragments.html#short-syntax" target="_blank" rel="noopener">React fragments</a></p><h4 id="2-class类中this绑定问题"><a href="#2-class类中this绑定问题" class="headerlink" title="2.class类中this绑定问题 "></a><font style="font-weight:700;color:#333;font-size:20px;">2.class类中this绑定问题 </font></h4><p><font style="color:blue;">类的方法内部如果含有this,默认指向类的实例,但是一些场景下使用,会导致this的指向偏离预期，所以需要绑定定义时候的this,也就是实例对象</font></p><p>如下</p><pre><code>&lt;!--html--&gt;&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;!--js--&gt;const btn = document.getElementById(&apos;btn&apos;);class CheckThis {  constructor(ele) {    this.ele = ele;    this.count = 0;    this.ele.addEventListener(&apos;click&apos;, this.click);  }  click() {    console.log(this); // DOM    this.count++;    console.log(this.count); // NaN  }}const thisInstance = new CheckThis(btn);</code></pre><p>在这里click方法中的this指的是dom节点而不是实例对象,</p><p><font style="color:blue;">因为addEventListener()将this的指针设置为冒泡事件的DOM元素</font></p><p>相当于 </p><pre><code>var m = this.click;this.ele.addEventListener(&apos;click&apos;, m) //此时m函数中this的指向创建事件的元素</code></pre><p>再看一个例子</p><pre><code>import React, { PureComponent } from &apos;react&apos;;class Index extends PureComponent {    testHandle(){       console.log(this); // undefined    };    reder(){        return (            &lt;Button onClick={this.testHandle}&gt;click&lt;/Button&gt;        )    }}</code></pre><p>React事件为合成事件，class并不会为方法自动绑定this到当前对象上,再由于<font style="color:red;">class 内部是严格模式</font>，所以 this 实际指向的是undefined,为避免这种this指向问题有几种方法来解决这种问题</p><h5 id="1-使用箭头函数"><a href="#1-使用箭头函数" class="headerlink" title=" 1.使用箭头函数"></a><font style="font-weight:700;color:#333;"> 1.使用箭头函数</font></h5><p><font style="color:blue;">直接在React元素中采用箭头函数</font>   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class="line">class Index extends PureComponent &#123;</span><br><span class="line">    testHandle()&#123;</span><br><span class="line">       console.log(this); &#x2F;&#x2F; Index实例对象</span><br><span class="line">    &#125;;</span><br><span class="line">    reder()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Button onClick&#x3D;&#123;(event)&#x3D;&gt;this.testHandle(event)&#125;&gt;click&lt;&#x2F;Button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为箭头函数中的this指向的是函数定义的对象,所以可以保证this总是指向当前组件的实例对象<br>优化点：直接在render方法中为元素事件定义事件的处理函数，每次render调用时，都会创建一个新的事件处理函数，带来额外的性能开销</p><h5 id="2-组件方法"><a href="#2-组件方法" class="headerlink" title=" 2.组件方法"></a><font style="font-weight:700;color:#333;"> 2.组件方法</font></h5><p><font style="color:blue;">直接将组件的方法赋值给元素的事件属性，同时在类的构造函数中，将这个方法的this绑定到当前对象。</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class="line">class Index extends PureComponent &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state&#x3D;&#123;&#125;</span><br><span class="line">        this.testHandle &#x3D; this.testHandle.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    testHandle()&#123;</span><br><span class="line">       console.log(this); &#x2F;&#x2F; Index实例对象</span><br><span class="line">    &#125;;</span><br><span class="line">    reder()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Button onClick&#x3D;&#123;this.testHandle&#125;&gt;click&lt;&#x2F;Button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处是每次render不会重新创建一个回调函数，没有额外的性能损失。但在构造函数中，为事件处理函数绑定this， 尤其是存在多个事件处理函数需要绑定时,这种模板式的代码还是会显得烦琐。而且对于函数传递参数来说不太方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class="line">class Index extends PureComponent &#123;</span><br><span class="line">    testHandle(params)&#123;</span><br><span class="line">       console.log(this,params); &#x2F;&#x2F; Index实例对象, &#123; test: &#39;1&#39; &#125;; </span><br><span class="line">    &#125;;</span><br><span class="line">    reder()&#123;</span><br><span class="line">        const params &#x3D; &#123; test: &#39;1&#39; &#125;;</span><br><span class="line">        return(</span><br><span class="line">             &lt;Button onClick&#x3D;&#123;this.testHandle.bind(this,params)&#125;&gt;click&lt;&#x2F;Button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式依然存在每次render都会创建一个函数的问题，但在需要为处理<font style="color:red;">传递额外参数</font>提供便利</p><h5 id="3-属性初始化语法"><a href="#3-属性初始化语法" class="headerlink" title=" 3.属性初始化语法"></a><font style="font-weight:700;color:#333;"> 3.属性初始化语法</font></h5><p><font style="color:blue;">使用ES 7的property initializers会自动为class中定义的方法绑定this</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; PureComponent &#125; from &#39;react&#39;;</span><br><span class="line">class Index extends PureComponent &#123;</span><br><span class="line">    testHandle &#x3D; (params)&#x3D;&gt;&#123;</span><br><span class="line">       console.log(this,params); &#x2F;&#x2F; Index实例对象, &#123; test: &#39;1&#39; &#125;; </span><br><span class="line">    &#125;;</span><br><span class="line">    reder()&#123;</span><br><span class="line">        const params &#x3D; &#123; test: &#39;1&#39; &#125;;</span><br><span class="line">        return(</span><br><span class="line">             &lt;Button onClick&#x3D;&#123;this.testHandle&#125;&gt;click&lt;&#x2F;Button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式既不需要在构造函数中手动绑定this， 也不需要担心组件重复渲染导致的函数重复创建问题。但是， property initializers这个特性还处于试验阶段， 默认是不支持的,不过， 使用官方脚手架Create React App创建的项目默认是支持这个特性的。你也可以自行在项目中引入babel的transform-class-properties插件获取这个特性支持。</p><h5 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h5><p>引用 <a href="">React+进阶之路</a></p></div><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;font-size:18px;color:#333;line-height:20px;font-family:楷体;&quot;&gt;

&lt;h4 id=&quot;1-React中关于render函数返回一个元素&quot;&gt;&lt;a href=&quot;#1-React中关于render函数返回一个
      
    
    </summary>
    
    
      <category term="技术" scheme="http://liyang.comeonone.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://liyang.comeonone.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="每日问题" scheme="http://liyang.comeonone.com/tags/%E6%AF%8F%E6%97%A5%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://liyang.comeonone.com/2020/03/26/hello-world/"/>
    <id>http://liyang.comeonone.com/2020/03/26/hello-world/</id>
    <published>2020-03-26T13:18:39.321Z</published>
    <updated>2020-03-26T13:18:39.321Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
